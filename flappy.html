<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy Warrior — Gentle Warrior</title>
<style>
  :root {
    --bg:#0f2b24; --panel:#123428; --muted:#9aa89a; --accent:#8be07a;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{background:linear-gradient(180deg,#072b1e 0%, #06241a 100%);color:#e7f7ef;display:flex;flex-direction:column;align-items:center;gap:16px;padding:20px;}
  .wrap{width:100%;max-width:880px;}
  h1{margin:6px 0 0;font-size:20px;text-align:center}
  .game-panel{background:rgba(0,0,0,0.18);padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.6);}
  canvas{display:block;width:100%;height:auto;border-radius:10px;background:#03221a}
  .controls{display:flex;gap:10px;align-items:center;margin-top:10px;flex-wrap:wrap}
  .btn{background:var(--accent);color:#042010;border:none;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600;}
  .btn.secondary{background:#1e3a2f;color:#bfe7c7}
  .status{margin-left:auto;color:var(--muted)}
  .box{margin-top:14px;padding:12px;border-radius:10px;background:rgba(0,0,0,0.18)}
  .share-preview{max-width:320px;border-radius:10px;overflow:hidden;border:4px solid rgba(255,255,255,0.04)}
  p.small{font-size:13px;color:var(--muted);margin:6px 0 0}
  .note{font-size:13px;color:#cfe6d6;margin-top:8px}
  footer{margin-top:20px;text-align:center;color:#9fbfa7;font-size:12px}
  @media(min-width:720px){h1{font-size:24px}}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Flappy Warrior — Gentle Warrior</h1>

    <div class="game-panel">
      <!-- Canvas -->
      <canvas id="game" width="800" height="600" aria-label="Flappy Warrior game"></canvas>

      <!-- Controls -->
      <div class="controls">
        <button id="startBtn" class="btn">Start</button>
        <button id="resetBtn" class="btn secondary">Reset</button>
        <button id="shareBtn" class="btn">Share score</button>
        <div class="status">Score: <span id="score">0</span></div>
      </div>

      <div class="box">
        <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
          <div>
            <strong>Your best</strong>
            <div id="bestDisplay" style="font-size:26px;margin-top:6px">0</div>
          </div>
          <div style="margin-left:auto">
            <img id="sharePreview" class="share-preview" src="flappy-share.png" alt="Flappy share card preview" />
          </div>
        </div>

        <p class="small">Tip: Tap or press Space to flap. Avoid pipes and beat your best score. When finished, share your run with the community.</p>
      </div>

      <div class="note">
        <strong>Important:</strong> All images must be in the same folder as this file (root). Filenames must match exactly:
        <ul>
          <li>flap-up.png</li>
          <li>flap-mid.png</li>
          <li>flap-down.png</li>
          <li>background.png</li>
          <li>pipe.png</li>
          <li>ground.png</li>
          <li>tap-start.png</li>
          <li>game-over.png</li>
          <li>flappy-share.png</li>
        </ul>
      </div>
    </div>

    <footer>© 2025 Gentle Warrior — gentlewarrior-universe.netlify.app</footer>
  </div>

<script>
/*
  Flappy Warrior minimal engine
  - Images are loaded from ASSET_PATH (empty string because images in root)
  - Filenames expected: flap-up.png, flap-mid.png, flap-down.png, background.png, pipe.png, ground.png, tap-start.png, game-over.png, flappy-share.png
*/
const ASSET_PATH = ""; // images are in repo root next to this file

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const shareBtn = document.getElementById('shareBtn');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('bestDisplay');

let images = {};
let loadedCount = 0;
const toLoad = {
  'bg': 'background.png',
  'pipe': 'pipe.png',
  'ground': 'ground.png',
  'flapUp': 'flap-up.png',
  'flapMid': 'flap-mid.png',
  'flapDown': 'flap-down.png',
  'tap': 'tap-start.png',
  'gameover': 'game-over.png',
  'share': 'flappy-share.png'
};

function loadAssets(cb){
  const keys = Object.keys(toLoad);
  keys.forEach(k=>{
    const img = new Image();
    img.src = ASSET_PATH + toLoad[k];
    img.onload = ()=> {
      images[k] = img;
      loadedCount++;
      if(loadedCount === keys.length) cb();
    };
    img.onerror = ()=> {
      console.error('Failed loading', toLoad[k]);
      // still attempt to continue to avoid hard fail
      loadedCount++;
      if(loadedCount === keys.length) cb();
    };
  });
}

/* Game state */
let running = false;
let pipes = [];
let gravity = 0.5;
let flapPower = -9;
let spawnInterval = 1500;
let lastSpawn = 0;
let score = 0;
let best = Number(localStorage.getItem('gw-flappy-best')||0);
bestEl.textContent = best;
let frame = 0;

/* Player */
const player = {
  x: 160,
  y: 260,
  w: 72,
  h: 64,
  vy: 0,
  frameIndex: 1,
  frameTimer: 0
};

function resetGame(){
  pipes = [];
  score = 0;
  scoreEl.textContent = score;
  player.y = 260; player.vy = 0; player.frameIndex = 1;
  running=false;
  startBtn.textContent = 'Start';
}

/* Input */
function flap(){
  if(!running){
    startGame();
    return;
  }
  player.vy = flapPower;
  player.frameIndex = 0; // show up frame immediately
  player.frameTimer = 0;
}

document.addEventListener('keydown', e=>{
  if(e.code === 'Space') { e.preventDefault(); flap(); }
});
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});
canvas.addEventListener('mousedown', e=>{ flap(); });

startBtn.addEventListener('click', startGame);
resetBtn.addEventListener('click', ()=>{
  resetGame();
  draw(); // redraw static
});
shareBtn.addEventListener('click', shareScore);

/* Spawning pipes */
function spawnPipe(){
  const gap = 140; // vertical gap
  const minY = 80;
  const maxY = H - 220;
  const top = Math.floor(Math.random()*(maxY-minY))+minY;
  pipes.push({x: W + 20, top: top, gap: gap, passed:false});
}

/* Collision check */
function collided(p){
  // simple box collision with pipes and ground
  if(player.y + player.h > H - 80) return true;
  if(player.y < 0) return true;
  // pipes: top pipe rect is (x,0) to (x+pipeW, top)
  const pipeW = 90;
  for(let pipe of pipes){
    // top
    if(rectIntersect(player.x, player.y, player.w, player.h, pipe.x, 0, pipeW, pipe.top)) return true;
    // bottom
    if(rectIntersect(player.x, player.y, player.w, player.h, pipe.x, pipe.top + pipe.gap, pipeW, H)) return true;
  }
  return false;
}
function rectIntersect(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
}

/* Game loop */
let lastTime = performance.now();
function loop(now){
  const dt = now - lastTime;
  lastTime = now;
  if(running){
    update(dt);
  }
  draw();
  frame++;
  requestAnimationFrame(loop);
}
function startGame(){
  if(running) return;
  running = true;
  startBtn.textContent = 'Playing...';
  lastSpawn = performance.now();
  lastTime = performance.now();
}

/* Update */
function update(dt){
  // physics
  player.vy += gravity;
  player.y += player.vy;

  // animate player frame
  player.frameTimer += dt;
  if(player.frameTimer > 100){
    player.frameTimer = 0;
    player.frameIndex = (player.frameIndex + 1) % 3; // 0,1,2 -> up,mid,down
  }

  // pipes movement and spawn
  const now = performance.now();
  if(now - lastSpawn > spawnInterval){
    spawnPipe();
    lastSpawn = now;
  }
  for(let i=pipes.length-1;i>=0;i--){
    pipes[i].x -= 2.6 + Math.min(2.6, score/50); // speed up slowly
    if(!pipes[i].passed && pipes[i].x + 90 < player.x){
      pipes[i].passed = true;
      score++;
      scoreEl.textContent = score;
      if(score > best){
        best = score;
        bestEl.textContent = best;
        localStorage.setItem('gw-flappy-best', best);
      }
    }
    if(pipes[i].x < -140) pipes.splice(i,1);
  }

  // collision
  if(collided()){
    running=false;
    startBtn.textContent = 'Start';
    // show game over overlay briefly (draw handles visual)
  }
}

/* Draw */
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // background
  if(images.bg) {
    // fill with tiled or scaled bg
    ctx.drawImage(images.bg, 0, 0, W, H);
  } else {
    ctx.fillStyle = '#072b1e';
    ctx.fillRect(0,0,W,H);
  }

  // pipes
  const pipeW = 90;
  ctx.save();
  for(let pipe of pipes){
    if(images.pipe){
      // top pipe (rotate)
      const topH = pipe.top;
      ctx.drawImage(images.pipe, 0, 0, images.pipe.width, images.pipe.height,
                    pipe.x, pipe.top - images.pipe.height, pipeW, images.pipe.height);
      // bottom pipe
      ctx.drawImage(images.pipe, 0, 0, images.pipe.width, images.pipe.height,
                    pipe.x, pipe.top + pipe.gap, pipeW, images.pipe.height);
    } else {
      ctx.fillStyle = '#2f6b4b';
      ctx.fillRect(pipe.x, 0, pipeW, pipe.top);
      ctx.fillRect(pipe.x, pipe.top + pipe.gap, pipeW, H);
    }
  }
  ctx.restore();

  // ground
  if(images.ground){
    ctx.drawImage(images.ground, 0, H-80, W, 80);
  } else {
    ctx.fillStyle = '#0b3b2b';
    ctx.fillRect(0,H-80,W,80);
  }

  // player (animated frames)
  let pImg = images.flapMid;
  if(player.frameIndex === 0 && images.flapUp) pImg = images.flapUp;
  if(player.frameIndex === 1 && images.flapMid) pImg = images.flapMid;
  if(player.frameIndex === 2 && images.flapDown) pImg = images.flapDown;

  if(pImg){
    ctx.drawImage(pImg, player.x, player.y, player.w, player.h);
  } else {
    ctx.fillStyle = '#8be07a';
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }

  // HUD overlay: tap instructions
  if(!running && images.tap){
    ctx.drawImage(images.tap, W/2 - 100, H/2 - 160, 200, 80);
  }

  // game over overlay
  if(!running && score>0 && images.gameover){
    ctx.drawImage(images.gameover, W/2 - 170, H/2 - 60, 340, 120);
  }
}

/* Share logic */
async function shareScore(){
  const url = location.href;
  const text = `I scored ${score} on Flappy Warrior — can you beat me? ${url}`;
  // If device supports navigator.share and we have share image, try to share image
  try {
    if(navigator.canShare && navigator.canShare({files:[]}) && images.share){
      // convert share image src to blob
      const resp = await fetch(ASSET_PATH + toLoad.share);
      const blob = await resp.blob();
      const file = new File([blob], 'flappy-share.png', {type: blob.type});
      await navigator.share({
        title: 'Flappy Warrior — Gentle Warrior',
        text: `Score: ${score}`,
        files: [file],
        url
      });
      return;
    }
  } catch(e){
    console.warn('Native file share failed', e);
  }

  // Otherwise fallback to navigator.share with text (mobile)
  if(navigator.share){
    try {
      await navigator.share({title:'Flappy Warrior', text, url});
      return;
    } catch(e){
      // user cancelled or share failed
    }
  }

  // Final fallback: copy to clipboard
  try {
    await navigator.clipboard.writeText(text);
    alert('Score + link copied to clipboard. Paste it anywhere to share!');
  } catch(e){
    // give user the raw text in a prompt
    prompt('Copy this to share', text);
  }
}

/* Resize canvas to device pixel ratio for crisp display */
function resize(){
  const ratio = window.devicePixelRatio || 1;
  const cssW = Math.min(880, window.innerWidth - 40);
  const cssH = Math.round(cssW * 0.75);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * ratio);
  canvas.height = Math.round(cssH * ratio);
  ctx.setTransform(ratio,0,0,ratio,0,0);
  W = canvas.width/ratio; H = canvas.height/ratio;
  draw();
}
window.addEventListener('resize', resize);

/* Preload assets and start loop */
loadAssets(()=>{
  resize();
  draw();
  requestAnimationFrame(loop);
});

/* initial state */
resetGame();

// allow tapping start from the big tap graphic as well
canvas.addEventListener('click', ()=>{
  if(!running) startGame();
});

// enable "Try again" behaviour: if game over and not running, clicking start will reset pipes & play
function endRound(){
  if(score > best){
    best = score;
    localStorage.setItem('gw-flappy-best', best);
    bestEl.textContent = best;
  }
}

/* Watch game state each frame to detect transition from playing to ended */
let lastRunning = false;
setInterval(()=> {
  if(lastRunning && !running){
    // just stopped (game over)
    endRound();
  }
  lastRunning = running;
}, 200);

</script>
</body>
</html>