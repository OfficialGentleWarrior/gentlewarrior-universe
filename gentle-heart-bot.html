<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>Gentle Heart — Your gentle companion</title>
<style>
:root{
  --emerald-900:#04331f;
  --emerald-800:#06442a;
  --emerald-700:#0b5b39;
  --emerald-600:#0e6e47;
  --emerald-500:#1aa667;
  --emerald-400:#49c88f;
  --bg:#f6fbf8;
  --white:#f7fff9;
  --muted:#cfe9d9;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
html,body{height:100%;margin:0;background:var(--bg);-webkit-font-smoothing:antialiased; -webkit-text-size-adjust:100%;}

/* Bubble */
#bubble{
  position:fixed; right:18px; bottom:18px; z-index:99999;
  width:68px; height:68px; border-radius:999px;
  background:linear-gradient(180deg,var(--emerald-500),var(--emerald-600));
  display:flex;align-items:center;justify-content:center;box-shadow:0 8px 26px rgba(3,30,20,.45);
  cursor:grab; touch-action:none; -webkit-user-drag:none; user-select:none;
  transition:box-shadow .12s ease, transform .12s ease;
}
#bubble:active{ cursor:grabbing; box-shadow:0 12px 36px rgba(3,30,20,.55); transform:scale(.98); }
#bubble img{width:72%;height:72%;border-radius:12px;object-fit:cover;display:block}

/* Panel */
#panel{
  position:fixed; right:18px; bottom:110px; z-index:99998;
  width:360px; max-width:92vw; height:640px; max-height:86vh;
  border-radius:14px; overflow:hidden; display:flex;flex-direction:column;
  background:var(--emerald-900); color:var(--white); transform:translateY(6px) scale(.99); opacity:0;
  transition:transform .14s ease,opacity .14s ease,right .12s ease,bottom .12s ease,max-height .12s ease;
  pointer-events:none;
  box-shadow:0 20px 60px rgba(3,30,20,.5);
}
#panel.show{transform:none;opacity:1; pointer-events:auto;}
.header{display:flex;align-items:center;padding:14px;gap:12px;background:linear-gradient(180deg,var(--emerald-800),var(--emerald-700));}
.header img{width:46px;height:46px;border-radius:10px;object-fit:cover;}
.title{font-weight:700;font-size:18px}
.subtitle{font-size:12px;color:var(--muted);margin-top:4px}
.header-right{margin-left:auto;display:flex;gap:8px;align-items:center}
.icon-btn{background:transparent;border:0;color:var(--white);padding:6px;border-radius:8px;cursor:pointer}

/* Chat area reserves space for input so messages never hidden */
/* --- FULL EMERALD PANEL BACKGROUND --- */
#panel {
  background: var(--emerald-900);
  color: var(--white);
}

/* --- CHAT AREA (messages zone) --- */
.chat-area{
  flex:1;
  display:flex;
  flex-direction:column;
  padding:14px;
  gap:12px;
  overflow:auto;
  background: var(--emerald-800); 
  scroll-behavior:smooth;
  padding-bottom:160px;
}

/* --- CONTROLS BAR --- */
.controls{
  position:absolute;
  left:0;
  right:0;
  bottom:0;
  padding:12px;
  border-top:1px solid rgba(255,255,255,0.05);
  display:flex;
  gap:8px;
  align-items:center;
  background: var(--emerald-800);
}

/* --- WHITE INPUT FIELD --- */
.input-wrap{
  flex:1;
  background:white;
  padding:10px 14px;
  border-radius:999px;
  display:flex;
  align-items:center;
  box-shadow:0 2px 8px rgba(0,0,0,0.20);
}

/* --- TEXT FIELD --- */
#userInput{
  flex:1;
  background:transparent;
  border:0;
  outline:0;
  color:var(--emerald-900);
  font-size:15px;
}

/* --- SEND BUTTON --- */
.send-btn{
  background:var(--emerald-400);
  border:0;
  color:var(--emerald-900);
  padding:10px 14px;
  border-radius:999px;
  cursor:pointer;
  font-weight:600;
}

/* Typing dots */
.typing{display:flex;gap:6px}
.dot{width:8px;height:8px;border-radius:50%;background:var(--muted);animation:blink 1s infinite}
@keyframes blink{0%,80%{opacity:0.2}40%{opacity:0.95}}

/* Modal: solid backdrop */
.modal-backdrop{position:fixed;inset:0;display:flex;align-items:end;justify-content:center;padding:18px;z-index:100000;background: rgba(4,51,31,0.95);transition:opacity .12s ease; pointer-events:none; opacity:0}
.modal-backdrop.show{pointer-events:auto; opacity:1}
.modal{pointer-events:auto;background:linear-gradient(180deg,var(--emerald-900),var(--emerald-800));color:var(--white);width:360px;max-width:96vw;border-radius:12px;padding:12px;box-shadow:0 20px 50px rgba(0,0,0,0.45)}
.hidden{display:none}

/* Error overlay */
#errorBox{position:fixed;left:12px;right:12px;top:12px;z-index:400000;background:#ffefef;color:#400;border-radius:10px;padding:10px;border:1px solid #f2c2c2;display:none;box-shadow:0 10px 30px rgba(0,0,0,0.18)}
#errorBox pre{white-space:pre-wrap;margin:0;font-size:13px}

@media(max-width:420px){
  #panel{width:92vw;height:86vh;right:6px;left:6px}
  .header img{width:40px;height:40px}
}
</style>
</head>
<body>

<!-- Inline fallback QA (so widget works even without qa.json) -->
<script id="qa-inline" type="application/json">
{
  "hi":"Hello! I'm Gentle Heart — how can I help you today?",
  "hello":"Hi there — tell me what's on your mind.",
  "help":"You can ask about breathing exercises, CP info, or just share how you feel.",
  "sad":"I'm sorry you're feeling sad. Would you like a breathing exercise?",
  "happy":"That's great — tell me what's making you happy?"
}
</script>

<!-- Error overlay -->
<div id="errorBox" role="alert"><strong>Script error — details:</strong><pre id="errorText"></pre></div>
<!-- Panel -->
<div id="panel" role="dialog" aria-modal="true" aria-hidden="true" class="">
  <div class="header" role="banner">
    <img src="avatar.png" alt="avatar" onerror="this.style.display='none'"/>
    <div>
      <div class="title">Gentle Heart</div>
      <div class="subtitle">Your gentle companion</div>
    </div>
    <div class="header-right" role="navigation" aria-label="Chat controls">
      <select id="countrySelect" aria-label="Country" style="background:transparent;color:var(--white);border:0;padding:6px 8px;border-radius:8px;">
        <option>Philippines</option><option>United States</option><option>United Kingdom</option><option>India</option>
      </select>

      <button id="gearBtn" class="icon-btn" title="Settings" aria-label="Settings">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="white" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"></path>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a.5.5 0 0 1 0 .71l-1.41 1.41a.5.5 0 0 1-.71 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33"/>
        </svg>
      </button>

      <button id="minBtn" class="icon-btn" title="Minimize" aria-label="Minimize">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="white" stroke-width="1.6"><path d="M5 12h14"/></svg>
      </button>
    </div>
  </div>

  <div id="chatArea" class="chat-area" role="log" aria-live="polite"></div>

  <div class="controls" role="group" aria-label="Message input">
    <form id="inputForm" autocomplete="off" style="display:flex;gap:8px;width:100%;align-items:center">
      <div class="input-wrap"><input id="userInput" name="q" placeholder="Say hello — ask gently" autocomplete="off" aria-label="Message input" /></div>
      <button type="submit" class="send-btn" aria-label="Send message">Send</button>
    </form>
  </div>
</div>

<!-- Settings modal (solid) -->
<div id="modalBackdrop" class="modal-backdrop hidden" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Settings">
    <h3 style="margin:0 0 8px 0">Settings</h3>
    <div style="display:flex;flex-direction:column;gap:8px">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer"><input id="kidsMode" type="checkbox" /> <span>Kids mode</span></label>
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer"><input id="privateMode" type="checkbox" /> <span>Private mode</span></label>
      <div><label style="display:block;margin-bottom:6px">Country</label>
        <select id="countryInModal" class="select" style="width:100%;padding:8px;border-radius:8px;border:0;background:rgba(255,255,255,0.03);color:var(--white)"><option>Philippines</option><option>United States</option></select>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="clearHistory" style="flex:1;padding:10px;border-radius:8px;border:0;cursor:pointer;background:#fff;color:var(--emerald-900)">Clear history</button>
        <button id="closeModal" style="flex:1;padding:10px;border-radius:8px;border:0;cursor:pointer;background:transparent;color:var(--white);border:1px solid rgba(255,255,255,0.06)">Close</button>
      </div>
    </div>
  </div>
</div>

<script>
/* Complete, fixed Gentle Heart widget
   - robust fetchQA + normalization (supports common shapes)
   - handleSend waits briefly for fetchQA (race) so qa.json is used if available
   - bubble drag/tap + panel + history intact
*/

(function(){
  // global error overlay
  window.addEventListener('error', function(ev){
    try{
      const box = document.getElementById('errorBox');
      const txt = document.getElementById('errorText');
      if(box && txt){
        box.style.display = 'block';
        txt.textContent = (ev && ev.message ? ev.message : String(ev)) + '\n' + (ev && ev.filename ? ev.filename+':'+ev.lineno+':'+ev.colno : '');
      }
      console.error('Captured error', ev);
    }catch(e){}
  });
  window.addEventListener('unhandledrejection', function(ev){
    try{
      const box = document.getElementById('errorBox');
      const txt = document.getElementById('errorText');
      if(box && txt){
        box.style.display = 'block';
        txt.textContent = 'Promise rejection: ' + (ev.reason && ev.reason.stack ? ev.reason.stack : String(ev.reason));
      }
      console.error('Unhandled rejection', ev);
    }catch(e){}
  });
})();

(function(){
  // DOM elements
  let originalBubble = document.getElementById('bubble');
// If bubble was removed intentionally, create a hidden placeholder so the script doesn't crash.
// This keeps the rest of the widget logic (panel open/minimize, API exposure) working.
if (!originalBubble) {
  originalBubble = document.createElement('div');
  originalBubble.id = 'bubble';
  originalBubble.style.display = 'none'; // hidden placeholder
  document.body.appendChild(originalBubble);
}
  const panel = document.getElementById('panel');
  const chatArea = document.getElementById('chatArea');
  const inputForm = document.getElementById('inputForm');
  const userInput = document.getElementById('userInput');
  const gearBtn = document.getElementById('gearBtn');
  const modalBackdrop = document.getElementById('modalBackdrop');
  const closeModal = document.getElementById('closeModal');
  const clearHistoryBtn = document.getElementById('clearHistory');
  const minBtn = document.getElementById('minBtn');

  // inline fallback QA
  let qaData = {};
  try{
    const inline = document.getElementById('qa-inline');
    if(inline && inline.textContent) qaData = JSON.parse(inline.textContent);
  }catch(e){ qaData = {}; }

  // normalized map (string -> string)
  let qaDataNormalized = {};

  function normalizeKeyForMap(s){ return String(s||'').toLowerCase().replace(/[^\w\s]/g,' ').replace(/\s+/g,' ').trim(); }

  // robust addNormalizedEntry
  function addNormalizedEntry(k, v){
    try{
      const nk = normalizeKeyForMap(k);
      if(!nk) return;
      // if value is string
      if(typeof v === 'string'){
        qaDataNormalized[nk] = v;
        return;
      }
      // if v is an object with common fields
      if(typeof v === 'object' && v !== null){
        if(typeof v.response === 'string'){ qaDataNormalized[nk] = v.response; return; }
        if(typeof v.a === 'string'){ qaDataNormalized[nk] = v.a; return; }
        if(typeof v.reply === 'string'){ qaDataNormalized[nk] = v.reply; return; }
        // array of strings
        if(Array.isArray(v) && v.length && typeof v[0] === 'string'){ qaDataNormalized[nk] = v[0]; return; }
        // find first string field
        for(const prop of Object.keys(v)){
          if(typeof v[prop] === 'string'){ qaDataNormalized[nk] = v[prop]; return; }
        }
        // fallback stringify
        try{ qaDataNormalized[nk] = JSON.stringify(v); return; }catch(e){}
      }
      // final fallback
      qaDataNormalized[nk] = String(v || '');
    }catch(e){
      console.warn('addNormalizedEntry error', e);
    }
  }

  // build from inline
  (function buildMapFromInline(){
    try{
      if(!qaData) return;
      if(Array.isArray(qaData)){
        qaData.forEach(item => {
          if(!item) return;
          if(item.q && (item.a || item.response || item.reply)) addNormalizedEntry(item.q, item.a || item.response || item.reply);
          else if(item.input && (item.a || item.response || item.reply)) addNormalizedEntry(item.input, item.a || item.response || item.reply);
          else if(item.prompt && (item.reply || item.response)) addNormalizedEntry(item.prompt, item.reply || item.response);
        });
        return;
      }
      if(typeof qaData === 'object'){
        Object.keys(qaData).forEach(k => {
          if(k === 'meta' || k === 'version' || k === 'hotlines' || k === 'items' || k === 'pairs') return;
          const v = qaData[k];
          if(typeof v === 'string') addNormalizedEntry(k, v);
          else if(typeof v === 'object' && v !== null && (v.a || v.response || v.reply)) addNormalizedEntry(k, v.a || v.response || v.reply);
        });
        if(Array.isArray(qaData.items)) qaData.items.forEach(it => { if(it) addNormalizedEntry(it.q||it.input||it.prompt, it.a||it.response||it.reply); });
        if(Array.isArray(qaData.pairs)) qaData.pairs.forEach(it => { if(it) addNormalizedEntry(it.q||it.input||it.prompt, it.a||it.response||it.reply); });
      }
    }catch(e){ console.warn('buildMapFromInline failed', e); }
  })();

  // robust fetchQA (tries multiple paths, tolerant parsing)
  async function fetchQA(){
    const paths = [
  'qa.json',
  './qa.json',
  '../qa.json',
  '/qa.json'
];
    for(const p of paths){
      try{
        const r = await fetch(p, {cache:'no-store'});
        if(!r.ok) continue;
        const txt = await r.text();
        if(!txt || !txt.trim()) continue;
        let parsed;
        try{ parsed = JSON.parse(txt); }catch(e){
          try{ parsed = JSON.parse(txt.replace(/^\uFEFF/, '').replace(/\/\*[\s\S]*?\*\/|\/\/.*$/gm, '')); }catch(err){ throw err; }
        }
        // normalize
        try{
          if(Array.isArray(parsed)){
            parsed.forEach(item => {
              if(!item) return;
              if(item.q && (item.a || item.response || item.reply)) addNormalizedEntry(item.q, item.a || item.response || item.reply);
              else if(item.input && (item.a || item.response || item.reply)) addNormalizedEntry(item.input, item.a || item.response || item.reply);
              else if(item.prompt && (item.reply || item.response)) addNormalizedEntry(item.prompt, item.reply || item.response);
            });
          } else if(parsed && typeof parsed === 'object'){
            Object.keys(parsed).forEach(k => {
              if(k === 'meta' || k === 'version' || k === 'hotlines' || k === 'items' || k === 'pairs') return;
              const val = parsed[k];
              if(typeof val === 'string') addNormalizedEntry(k, val);
              else if(typeof val === 'object' && val !== null){
                if(val.a || val.response || val.reply) addNormalizedEntry(k, val.a || val.response || val.reply);
              }
            });
            if(Array.isArray(parsed.items)) parsed.items.forEach(it => { if(it) addNormalizedEntry(it.q || it.input || it.prompt, it.a || it.response || it.reply); });
            if(Array.isArray(parsed.pairs)) parsed.pairs.forEach(it => { if(it) addNormalizedEntry(it.q || it.input || it.prompt, it.a || it.response || it.reply); });
          }
        }catch(normErr){
          console.warn('error normalizing parsed qa.json', normErr);
        }

        if(parsed) qaData = parsed;
        console.info('qa.json loaded and normalized from', p);
        return true;
      }catch(err){
        console.warn('fetchQA try failed for', p, err);
      }
    }
    console.warn('qa.json not found or unreadable; using inline fallback.');
    return false;
  }
  // initial background fetch
  fetchQA().catch(()=>{});

  // history
  let history = [];
  try{ history = JSON.parse(localStorage.getItem('gh_history') || '[]'); }catch(e){ history = []; }
  function saveHistory(){ try{ localStorage.setItem('gh_history', JSON.stringify(history)); }catch(e){} }
  function renderHistory(){ if(!chatArea) return; chatArea.innerHTML=''; for(const h of history){ if(h.role==='user') addUserBubble(h.text); else addBotBubble(h.text); } requestAnimationFrame(()=> chatArea.scrollTop = chatArea.scrollHeight); }

  // bubble replacement to clear old listeners
  let bubble = originalBubble;
  (function replaceBubble(){
    try{
      const clone = originalBubble.cloneNode(true);
      originalBubble.parentNode.replaceChild(clone, originalBubble);
      bubble = clone;
      bubble.style.pointerEvents = 'auto';
    }catch(e){}
  })();

  // helpers
  function tokensOf(s){ return String(s||'').split(/\s+/).filter(Boolean); }
  function chooseRandom(a){ if(!Array.isArray(a)||!a.length) return null; return a[Math.floor(Math.random()*a.length)]; }

  function lookupReply(q){
    if(!q) return "Tell me more — I'm listening.";
    const input = normalizeKeyForMap(q);
    if(qaDataNormalized[input]) return qaDataNormalized[input];

    // fuzzy match by token overlap
    const candidates = Object.keys(qaDataNormalized || {});
    if(candidates.length){
      const inputTokens = tokensOf(input), inputSet = new Set(inputTokens);
      let best = { key:null, score:0 };
      for(const k of candidates){
        const kTokens = tokensOf(k);
        if(!kTokens.length) continue;
        let shared = 0;
        for(const t of kTokens) if(inputSet.has(t)) shared++;
        const score = shared / Math.sqrt(kTokens.length * Math.max(1, inputTokens.length));
        if(score > best.score) best = { key:k, score };
      }
      if(best.key && best.score >= 0.25) return qaDataNormalized[best.key];
    }

    if(/\b(sad|unhappy|depressed|down)\b/.test(input)) return qaData['sad'] || "I'm sorry you're feeling sad. Would you like a breathing exercise?";
    if(/\b(happy|glad|good|great|joy)\b/.test(input)) return qaData['happy'] || "That's great — tell me what's making you happy?";

    return qaData['help'] || "Thanks for sharing — tell me more, or ask about breathing exercises or CP info.";
  }

  // renderers
  function addBotBubble(text, opts){
    if(!chatArea) return null;
    const w = document.createElement('div'); w.className='msg bot-msg';
    const img = document.createElement('img'); img.src='avatar.png'; img.alt='Gentle Heart'; img.onerror = ()=>img.style.display='none';
    const t = document.createElement('div'); t.className='text';
    if(opts && opts.isTyping){ const typ = document.createElement('div'); typ.className='typing'; typ.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>'; t.appendChild(typ); }
    else t.textContent = text || '';
    w.appendChild(img); w.appendChild(t); chatArea.appendChild(w); chatArea.scrollTop = chatArea.scrollHeight;
    return w;
  }
  function addUserBubble(text){ if(!chatArea) return; const d = document.createElement('div'); d.className='msg user-msg'; d.textContent = text || ''; chatArea.appendChild(d); chatArea.scrollTop = chatArea.scrollHeight; }

  // send flow — waits briefly for fetchQA (race)
  let sendLock = false;
  async function handleSend(text){
    if(sendLock) return;
    if(!text || !text.trim()) return;
    sendLock = true;
    try{
      history.push({role:'user', text}); saveHistory();
      addUserBubble(text);
      if(userInput) userInput.value = '';

      const typingNode = addBotBubble('', {isTyping:true});

      // Try to fetch latest qa.json but bound the wait (race)
      try{
        const fetchPromise = fetchQA();
        await Promise.race([fetchPromise, new Promise(r => setTimeout(r, 1600))]);
      }catch(e){ console.warn('fetchQA race error', e); }

      // small pacing for typing feel
      await new Promise(r=>setTimeout(r, 400));

      const reply = lookupReply(text);
      const container = typingNode.querySelector('.text');
      if(container) container.textContent = reply;
      history.push({role:'bot', text:reply}); saveHistory();
      chatArea.scrollTop = chatArea.scrollHeight;
    }catch(err){
      console.error('handleSend error', err);
      addBotBubble("Oops — something went wrong. Try again?");
    }finally{
      sendLock = false;
    }
  }

  // render history initially
  renderHistory();

  // form submit
  if(inputForm){
    inputForm.addEventListener('submit', function(e){
      e.preventDefault();
      try{ handleSend(userInput && userInput.value); }catch(err){ console.error(err); }
    });
  }

  // panel helpers
  function positionPanelAboveBubble(){
    if(!panel || !bubble) return;
    try{
      const br = bubble.getBoundingClientRect();
      const right = Math.max(12, window.innerWidth - (br.left + br.width));
      panel.style.right = right + 'px';
      panel.style.bottom = Math.min(Math.max(12, window.innerHeight - br.top + 18), window.innerHeight - 80) + 'px';
      panel.style.maxHeight = Math.min(window.innerHeight - 120, 0.86 * window.innerHeight) + 'px';
    }catch(e){}
  }

  function openPanel(){ if(!panel) return; fetchQA().catch(()=>{}); panel.classList.add('show'); panel.setAttribute('aria-hidden','false'); positionPanelAboveBubble(); setTimeout(()=>{ try{ if(userInput) userInput.focus(); chatArea.scrollTop = chatArea.scrollHeight; }catch(e){} }, 60); }
  function minimizePanel(){ if(!panel) return; panel.classList.remove('show'); panel.setAttribute('aria-hidden','true'); }

  // bubble click toggle
  if(bubble){
    bubble.addEventListener('click', function(e){
      try{
        const isShown = panel && panel.classList && panel.classList.contains('show');
        if(isShown) minimizePanel();
        else openPanel();
      }catch(err){ console.error(err); }
    });
    bubble.addEventListener('keydown', function(e){ if(e.key==='Enter'||e.key===' ') { if(panel.classList.contains('show')) minimizePanel(); else openPanel(); } });
  }

  // settings modal
  if(gearBtn){
    gearBtn.addEventListener('click', function(ev){
      ev && ev.stopPropagation();
      if(!modalBackdrop) return;
      modalBackdrop.classList.add('show'); modalBackdrop.classList.remove('hidden');
      try{ document.getElementById('kidsMode').checked = JSON.parse(localStorage.getItem('gh_kids')||'false'); document.getElementById('privateMode').checked = JSON.parse(localStorage.getItem('gh_private')||'false'); }catch(e){}
    });
  }
  if(closeModal){
    closeModal.addEventListener('click', function(){
      modalBackdrop.classList.remove('show'); modalBackdrop.classList.add('hidden');
      try{ localStorage.setItem('gh_kids', JSON.stringify(document.getElementById('kidsMode').checked)); localStorage.setItem('gh_private', JSON.stringify(document.getElementById('privateMode').checked)); }catch(e){}
    });
  }
  modalBackdrop.addEventListener('click', function(ev){ if(ev.target === modalBackdrop){ modalBackdrop.classList.remove('show'); modalBackdrop.classList.add('hidden'); }});
  if(clearHistoryBtn){
    clearHistoryBtn.addEventListener('click', function(ev){ ev && ev.preventDefault(); history=[]; saveHistory(); renderHistory(); });
  }
  if(minBtn) minBtn.addEventListener('click', function(ev){ ev && ev.stopPropagation(); minimizePanel(); });

  // click outside to close
  document.addEventListener('click', function(ev){
    if(!panel || !bubble) return;
    if(!panel.classList.contains('show')) return;
    if(modalBackdrop && modalBackdrop.classList.contains('show')) return;
    if(panel.contains(ev.target) || bubble.contains(ev.target)) return;
    minimizePanel();
  });

  // drag/tap logic (robust)
  (function enableDrag(){
    if(!bubble) return;
    let active=false, sx=0, sy=0, tx=0, ty=0, moved=false, lastUp=0;
    const threshold = 6;
    try{
      const saved = JSON.parse(localStorage.getItem('gh_bubble_pos') || 'null');
      if(saved && typeof saved.x === 'number' && typeof saved.y === 'number') bubble.style.transform = `translate(${saved.x}px, ${saved.y}px)`;
    }catch(e){}
    function readTransform(){
      const m = window.getComputedStyle(bubble).transform;
      if(m && m !== 'none'){
        const vals = m.match(/matrix.*\((.+)\)/);
        if(vals){ const arr = vals[1].split(',').map(x=>parseFloat(x)); return {x: arr[4]||0, y: arr[5]||0}; }
      }
      return {x:0,y:0};
    }
    function clampFinal(nx, ny){
      const rect = bubble.getBoundingClientRect();
      const bw = rect.width, bh = rect.height;
      const left = (rect.left + nx - readTransform().x);
      const top = (rect.top + ny - readTransform().y);
      const minLeft = 6, minTop = 6;
      const maxLeft = Math.max(6, window.innerWidth - bw - 6);
      const maxTop = Math.max(6, window.innerHeight - bh - 6);
      const clampedLeft = Math.min(Math.max(left, minLeft), maxLeft);
      const clampedTop = Math.min(Math.max(top, minTop), maxTop);
      const cur = readTransform();
      return { x: clampedLeft - (rect.left - cur.x), y: clampedTop - (rect.top - cur.y) };
    }
    function onDown(e){
      active=true; moved=false;
      const p = e.touches ? e.touches[0] : e;
      sx = p.clientX; sy = p.clientY;
      const cur = readTransform(); tx = cur.x; ty = cur.y;
      try{ e.pointerId && bubble.setPointerCapture && bubble.setPointerCapture(e.pointerId); }catch(err){}
      (e.preventDefault && e.preventDefault());
    }
    function onMove(e){
      if(!active) return;
      const p = e.touches ? e.touches[0] : e;
      const dx = p.clientX - sx, dy = p.clientY - sy;
      if(!moved && (Math.abs(dx) > threshold || Math.abs(dy) > threshold)) moved = true;
      const nx = tx + dx, ny = ty + dy;
      bubble.style.transform = `translate(${nx}px, ${ny}px)`;
      (e.preventDefault && e.preventDefault());
    }
    function onUp(e){
      if(!active) return;
      active=false;
      lastUp = Date.now();
      if(!moved){
        setTimeout(()=>{ if(Date.now() - lastUp < 150){ if(panel && panel.classList && panel.classList.contains('show')) minimizePanel(); else openPanel(); } }, 30);
        return;
      }
      const cur = readTransform();
      const rect = bubble.getBoundingClientRect();
      const centerX = rect.left + rect.width/2;
      const screenMid = window.innerWidth/2;
      let final = clampFinal(cur.x, cur.y);
      if(centerX < screenMid){
        final.x = 12;
      } else {
        final.x = window.innerWidth - rect.width - 12 - (rect.left - cur.x);
      }
      final.y = Math.min(Math.max(final.y, -rect.top + 12), window.innerHeight - rect.bottom - 12);
      bubble.style.transform = `translate(${final.x}px, ${final.y}px)`;
      try{ localStorage.setItem('gh_bubble_pos', JSON.stringify({x: final.x, y: final.y})); }catch(e){}
    }
    bubble.addEventListener('pointerdown', onDown, {passive:false});
    window.addEventListener('pointermove', onMove, {passive:false});
    window.addEventListener('pointerup', onUp, {passive:false});
    bubble.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp, {passive:false});
    bubble.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  })();

  // input focus/resize handling
  if(userInput){
    userInput.addEventListener('focus', ()=> setTimeout(()=> {
      if(panel && !panel.classList.contains('show')) openPanel();
      try{ const vh = window.innerHeight || document.documentElement.clientHeight; panel.style.maxHeight = Math.max(300, vh - 120) + 'px'; chatArea.scrollTop = chatArea.scrollHeight; userInput.scrollIntoView({behavior:'smooth', block:'center'}); }catch(e){}
    }, 250));
    userInput.addEventListener('blur', ()=> setTimeout(()=> { try{ panel.style.maxHeight = Math.min(window.innerHeight - 120, 0.86 * window.innerHeight) + 'px'; }catch(e){} },150));
    let lastInner = window.innerHeight;
    window.addEventListener('resize', function(){
      try{
        const now = window.innerHeight;
        if(now < lastInner - 80){ panel.style.maxHeight = Math.max(260, now - 120) + 'px'; setTimeout(()=> chatArea.scrollTop = chatArea.scrollHeight, 60); }
        else panel.style.maxHeight = Math.min(now - 120, 0.86 * now) + 'px';
        lastInner = now;
      }catch(e){}
    });
  }

  window.addEventListener('orientationchange', ()=> setTimeout(()=>{ try{ const br=bubble.getBoundingClientRect(); panel.style.right = Math.max(12, window.innerWidth - (br.left + br.width)) + 'px'; }catch(e){} }, 300));
  window.addEventListener('resize', ()=> setTimeout(()=>{ try{ const br=bubble.getBoundingClientRect(); panel.style.right = Math.max(12, window.innerWidth - (br.left + br.width)) + 'px'; }catch(e){} }, 160));

  // expose debug API
  window.GentleHeart = { openPanel, minimizePanel, fetchQA, qaDataNormalized };

})(); // end IIFE
</script>
</body>
</html>
