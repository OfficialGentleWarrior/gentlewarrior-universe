<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>Gentle Heart — Your gentle companion</title>
<style>
:root{
  --emerald-900:#04331f;
  --emerald-800:#06442a;
  --emerald-700:#0b5b39;
  --emerald-600:#0e6e47;
  --emerald-500:#1aa667;
  --emerald-400:#49c88f;
  --bg:#f6fbf8;
  --white:#f7fff9;
  --muted:#cfe9d9;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
html,body{height:100%;margin:0;background:var(--bg);-webkit-font-smoothing:antialiased; -webkit-text-size-adjust:100%;}
/* Bubble */
#bubble{
  position:fixed; right:18px; bottom:18px; z-index:100000;
  width:68px; height:68px; border-radius:999px;
  background:linear-gradient(180deg,var(--emerald-500),var(--emerald-600));
  display:flex;align-items:center;justify-content:center;box-shadow:0 8px 26px rgba(3,30,20,.45);
  cursor:grab; touch-action:none; user-select:none;
  transition:box-shadow .12s ease, transform .12s ease, left .12s ease, top .12s ease, right .12s ease, bottom .12s ease;
}
#bubble:active{ cursor:grabbing; box-shadow:0 12px 36px rgba(3,30,20,.55); transform:scale(.98); }
#bubble img{width:72%;height:72%;border-radius:12px;object-fit:cover;display:block;}

/* Panel */
#panel{
  position:fixed; right:18px; bottom:110px; z-index:100001;
  width:360px; max-width:92vw; height:640px; max-height:86vh;
  border-radius:14px; overflow:hidden; display:flex;flex-direction:column;
  background:var(--emerald-900); color:var(--white); transform:translateY(6px) scale(.99); opacity:0;
  transition:transform .14s ease,opacity .14s ease,right .12s ease,bottom .12s ease,left .12s ease,max-height .12s ease;
  pointer-events:none;
  box-shadow:0 20px 60px rgba(3,30,20,.5);
}
#panel.show{transform:none;opacity:1; pointer-events:auto;}
.header{display:flex;align-items:center;padding:14px;gap:12px;background:linear-gradient(180deg,var(--emerald-800),var(--emerald-700));}
.header img{width:46px;height:46px;border-radius:10px;object-fit:cover;}
.title{font-weight:700;font-size:18px}
.subtitle{font-size:12px;color:var(--muted);margin-top:4px}
.header-right{margin-left:auto;display:flex;gap:8px;align-items:center}
.icon-btn{background:transparent;border:0;color:var(--white);padding:6px;border-radius:8px;cursor:pointer}

/* Chat area: fixed padding-bottom so input never covers last messages */
.chat-area{flex:1;display:flex;flex-direction:column;padding:14px;gap:12px;overflow:auto;background:linear-gradient(180deg,#05291822,transparent);scroll-behavior:smooth;padding-bottom:110px;}
.msg{max-width:78%;padding:12px 14px;border-radius:12px;line-height:1.3;display:inline-block;word-break:break-word}
.bot-msg{background:linear-gradient(180deg,var(--emerald-800),var(--emerald-700));align-self:flex-start;display:flex;gap:10px;align-items:flex-start;color:var(--white)}
.bot-msg img{width:36px;height:36px;border-radius:8px;flex:0 0 36px;object-fit:cover}
.user-msg{background:var(--white);color:var(--emerald-900);align-self:flex-end;border-radius:12px;padding:10px 14px;}

/* Input area - fixed in panel, not overlapping chat because chat has padding-bottom */
.controls{position:absolute;left:0;right:0;bottom:0;padding:12px;border-top:1px solid rgba(255,255,255,0.03);display:flex;gap:8px;align-items:center;background:linear-gradient(180deg, rgba(2,20,12,0.06), rgba(2,20,12,0.02));}
.input-wrap{flex:1;background:rgba(255,255,255,0.04);padding:10px 12px;border-radius:999px;display:flex;align-items:center}
#userInput{flex:1;background:transparent;border:0;outline:0;color:var(--white);font-size:15px}
.send-btn{background:var(--emerald-400);border:0;color:var(--emerald-900);padding:8px 12px;border-radius:999px;cursor:pointer}
.typing{display:flex;gap:6px}
.dot{width:8px;height:8px;border-radius:50%;background:var(--muted);animation:blink 1s infinite}
@keyframes blink{0%,80%{opacity:0.2}40%{opacity:0.95}}

/* Solid modal (non-transparent) */
.modal-backdrop{
  position:fixed;inset:0;display:flex;align-items:end;justify-content:center;padding:18px;z-index:100010;
  background: rgba(4,51,31,0.95);
  transition:opacity .12s ease; pointer-events:none; opacity:0;
}
.modal-backdrop.show{pointer-events:auto; opacity:1;}
.modal{pointer-events:auto;background:linear-gradient(180deg,var(--emerald-900),var(--emerald-800));color:var(--white);width:360px;max-width:96vw;border-radius:12px;padding:12px;box-shadow:0 20px 50px rgba(0,0,0,0.45)}
.hidden{display:none}

/* Error overlay */
#errorBox{position:fixed;left:12px;right:12px;top:12px;z-index:400000;background:#ffefef;color:#400;border-radius:10px;padding:10px;border:1px solid #f2c2c2;display:none;box-shadow:0 10px 30px rgba(0,0,0,0.18)}
#errorBox pre{white-space:pre-wrap;margin:0;font-size:13px}

@media(max-width:420px){
  #panel{width:92vw;height:86vh;right:6px;left:6px}
  .header img{width:40px;height:40px}
}
</style>
</head>
<body>

<!-- Inline fallback QA (ensures file never blank) -->
<script id="qa-inline" type="application/json">
{
  "hi":"Hello! I'm Gentle Heart — how can I help you today?",
  "hello":"Hi there — tell me what's on your mind.",
  "help":"You can ask about breathing exercises, CP info, or just share how you feel.",
  "breathing":"Try this: Inhale for 4, hold 2, exhale 6. Repeat 4 times.",
  "cp":"CP stands for Cerebral Palsy — it's a group of movement disorders. Ask me more if you want details.",
  "clear history success":"History cleared."
}
</script>

<!-- Error overlay (shows if runtime error occurs) -->
<div id="errorBox" role="alert"><strong>Script error — details:</strong><pre id="errorText"></pre></div>

<!-- Bubble -->
<div id="bubble" role="button" aria-label="Open Gentle Heart" tabindex="0" title="Gentle Heart — tap to open">
  <img src="avatar.png" alt="Gentle Heart avatar" onerror="this.style.display='none'"/>
</div>

<!-- Panel -->
<div id="panel" role="dialog" aria-modal="true" aria-hidden="true" class="">
  <div class="header" role="banner">
    <img src="avatar.png" alt="avatar" onerror="this.style.display='none'"/>
    <div>
      <div class="title">Gentle Heart</div>
      <div class="subtitle">Your gentle companion</div>
    </div>
    <div class="header-right" role="navigation" aria-label="Chat controls">
      <select id="countrySelect" aria-label="Country" style="background:transparent;color:var(--white);border:0;padding:6px 8px;border-radius:8px;">
        <option>Philippines</option><option>United States</option><option>United Kingdom</option><option>India</option>
      </select>

      <!-- REPLACED: cleaner gear icon (simple, crisp) -->
      <button id="gearBtn" class="icon-btn" title="Settings" aria-label="Settings">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="white" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"></path>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a.5.5 0 0 1 0 .71l-1.41 1.41a.5.5 0 0 1-.71 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 .95l-.21.72a.5.5 0 0 1-.48.34h-2.82a.5.5 0 0 1-.48-.34l-.21-.72a1.65 1.65 0 0 0-1-.95 1.65 1.65 0 0 0-1.82.33l-.06.06a.5.5 0 0 1-.71 0L4.6 18.6a.5.5 0 0 1 0-.71l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-.95-1l-.72-.21a.5.5 0 0 1-.34-.48V9.59a.5.5 0 0 1 .34-.48l.72-.21a1.65 1.65 0 0 0 .95-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a.5.5 0 0 1 0-.71L6.5 2.6a.5.5 0 0 1 .71 0l.06.06a1.65 1.65 0 0 0 1.82.33l.72-.21a.5.5 0 0 1 .48.34v2.82a.5.5 0 0 1-.34.48l-.72.21a1.65 1.65 0 0 0-.95 1 1.65 1.65 0 0 0 .33 1.82l.06.06a.5.5 0 0 1 0 .71l-1.41 1.41a.5.5 0 0 1-.71 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33"/>
        </svg>
      </button>

      <button id="minBtn" class="icon-btn" title="Minimize" aria-label="Minimize">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="white" stroke-width="1.6"><path d="M5 12h14"/></svg>
      </button>
    </div>
  </div>

  <div id="chatArea" class="chat-area" role="log" aria-live="polite"></div>

  <div class="controls" role="group" aria-label="Message input">
    <form id="inputForm" autocomplete="off" style="display:flex;gap:8px;width:100%;align-items:center">
      <div class="input-wrap"><input id="userInput" name="q" placeholder="Say hello — ask gently" autocomplete="off" aria-label="Message input" /></div>
      <button type="submit" class="send-btn" aria-label="Send message">Send</button>
    </form>
  </div>
</div>

<!-- Modal -->
<div id="modalBackdrop" class="modal-backdrop hidden" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Settings">
    <h3 style="margin:0 0 8px 0">Settings</h3>
    <div style="display:flex;flex-direction:column;gap:8px">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer"><input id="kidsMode" type="checkbox" /> <span>Kids mode</span></label>
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer"><input id="privateMode" type="checkbox" /> <span>Private mode</span></label>
      <div><label style="display:block;margin-bottom:6px">Country</label>
        <select id="countryInModal" class="select" style="width:100%;padding:8px;border-radius:8px;border:0;background:rgba(255,255,255,0.03);color:var(--white)"><option>Philippines</option><option>United States</option></select>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="clearHistory" style="flex:1;padding:10px;border-radius:8px;border:0;cursor:pointer;background:#fff;color:var(--emerald-900)">Clear history</button>
        <button id="closeModal" style="flex:1;padding:10px;border-radius:8px;border:0;cursor:pointer;background:transparent;color:var(--white);border:1px solid rgba(255,255,255,0.06)">Close</button>
      </div>
    </div>
  </div>
</div>

<script>
/* Robust chat widget
   - inline qa fallback ensures not blank
   - background fetch for external qa.json (retries on panel open)
   - better reply matching (exact -> includes -> word-match)
   - chat area fixed padding so input never hides messages
*/

(function(){
  // error overlay handlers
  window.addEventListener('error', function(ev){
    try{
      const box = document.getElementById('errorBox');
      const txt = document.getElementById('errorText');
      box.style.display = 'block';
      txt.textContent = (ev && ev.message ? ev.message : String(ev)) + '\\n' + (ev && ev.filename ? ev.filename+':'+ev.lineno+':'+ev.colno : '');
      console.error('Captured error', ev);
    }catch(e){}
  });
  window.addEventListener('unhandledrejection', function(ev){
    try{
      const box = document.getElementById('errorBox');
      const txt = document.getElementById('errorText');
      box.style.display = 'block';
      txt.textContent = 'Promise rejection: ' + (ev.reason && ev.reason.stack ? ev.reason.stack : String(ev.reason));
      console.error('Unhandled rejection', ev);
    }catch(e){}
  });
})();

(function(){
  const bubble = document.getElementById('bubble');
  const panel = document.getElementById('panel');
  const chatArea = document.getElementById('chatArea');
  const inputForm = document.getElementById('inputForm');
  const userInput = document.getElementById('userInput');
  const gearBtn = document.getElementById('gearBtn');
  const modalBackdrop = document.getElementById('modalBackdrop');
  const closeModal = document.getElementById('closeModal');
  const clearHistoryBtn = document.getElementById('clearHistory');
  const minBtn = document.getElementById('minBtn');
  const kidsModeCheckbox = document.getElementById('kidsMode');
  const privateModeCheckbox = document.getElementById('privateMode');

  // qa data object — may be object map or array of {q,a}
  let qaData = {};
  // load inline fallback immediately
  try{
    const inline = document.getElementById('qa-inline');
    if(inline && inline.textContent) qaData = JSON.parse(inline.textContent);
  }catch(e){
    qaData = {};
  }

  // function to fetch external qa.json (background). Safe: won't throw.
  async function fetchQA(){
    try{
      const res = await fetch('./qa.json', {cache:'no-store'});
      if(!res.ok) throw new Error('no qa.json');
      const j = await res.json();
      if(j) {
        qaData = j;
        console.info('qa.json loaded');
        return true;
      }
    }catch(e){
      console.warn('qa.json not loaded', e);
      return false;
    }
    return false;
  }

  // call fetchQA once at init, and again each time panel opens (to pick up file added later)
  fetchQA().catch(()=>{});

  // history persisted
  let history = [];
  try{ history = JSON.parse(localStorage.getItem('gh_history') || '[]'); }catch(e){ history = []; }
  if(!history || history.length === 0){ history = [{role:'bot', text:"Welcome — tap the bubble to open chat. I'm Gentle Heart."}]; try{ localStorage.setItem('gh_history', JSON.stringify(history)); }catch(e){} }

  // RENDERING (keeps conversation layout stable)
  function renderHistory(){
    if(!chatArea) return;
    chatArea.innerHTML = '';
    for(const h of history){
      if(h.role === 'user') createUserBubble(h.text);
      else createBotBubble(h.text);
    }
    // keep scroll at bottom
    requestAnimationFrame(()=> chatArea.scrollTop = chatArea.scrollHeight);
  }

  // create message nodes (bot left, user right). Non-destructive (no layout jumps).
  function createBotBubble(text, opts){
    const w = document.createElement('div'); w.className='msg bot-msg';
    const img = document.createElement('img'); img.src='avatar.png'; img.alt='Gentle Heart'; img.onerror = ()=>img.style.display='none';
    const t = document.createElement('div'); t.className='text';
    if(opts && opts.typing){ const typ=document.createElement('div'); typ.className='typing'; typ.innerHTML='<div class="dot"></div><div class="dot"></div><div class="dot"></div>'; t.appendChild(typ); }
    else t.textContent = text || '';
    w.appendChild(img); w.appendChild(t); chatArea.appendChild(w); chatArea.scrollTop = chatArea.scrollHeight;
    return w;
  }
  function createUserBubble(text){
    const d = document.createElement('div'); d.className='msg user-msg'; d.textContent = text || ''; chatArea.appendChild(d); chatArea.scrollTop = chatArea.scrollHeight;
    return d;
  }

  // Smarter reply matching:
  // - exact key (case-insensitive)
  // - if qaData is array of {q,a}, exact match by q
  // - includes (key includes known key)
  // - word-match: break user input words, look for any qa key that contains those words
  function lookupReply(raw){
    if(!raw) return "Tell me more — I'm listening.";
    const s = raw.trim().toLowerCase();

    // direct exact in object map
    if(qaData && typeof qaData === 'object' && !Array.isArray(qaData)){
      // direct key
      if(qaData[s]) return qaData[s];
      // try keys normalized
      for(const k of Object.keys(qaData)){
        if(k && typeof k === 'string' && k.trim().toLowerCase() === s) return qaData[k];
      }
    }

    // if array of {q,a}
    if(Array.isArray(qaData)){
      const exact = qaData.find(x => (x.q||'').trim().toLowerCase() === s);
      if(exact) return exact.a;
    }

    // includes matching (long keys)
    try{
      if(typeof qaData === 'object' && !Array.isArray(qaData)){
        for(const k of Object.keys(qaData)){
          const nk = k.trim().toLowerCase();
          if(nk && s.includes(nk)) return qaData[k];
        }
      } else if(Array.isArray(qaData)){
        for(const item of qaData){
          const nk = (item.q||'').trim().toLowerCase();
          if(nk && s.includes(nk)) return item.a;
        }
      }
    }catch(e){}

    // word-match: check each word of user input against keys
    const words = s.split(/\s+/).filter(Boolean);
    if(words.length){
      if(typeof qaData === 'object' && !Array.isArray(qaData)){
        for(const k of Object.keys(qaData)){
          const nk = k.trim().toLowerCase();
          for(const w of words){
            if(w.length>2 && nk.includes(w)) return qaData[k];
          }
        }
      } else if(Array.isArray(qaData)){
        for(const item of qaData){
          const nk = (item.q||'').trim().toLowerCase();
          for(const w of words){
            if(w.length>2 && nk.includes(w)) return item.a;
          }
        }
      }
    }

    // fallback suggestions
    const fallback = qaData['default'] || qaData['help'] || "Thanks for sharing — tell me more, or ask about breathing exercises or CP info.";
    return fallback;
  }

  // SEND handler with 2s typing
  let sendLock = false;
  async function handleSend(text){
    if(sendLock) return;
    if(!text || !text.trim()) return;
    sendLock = true;
    history.push({role:'user', text}); persistHistory();
    createUserBubble(text);
    if(userInput) userInput.value = '';

    // add typing bubble
    const typingNode = createBotBubble('', {typing:true});
    // ensure QA is refreshed when panel opened (try once more)
    // (non-blocking)
    fetchQA().catch(()=>{});

    await new Promise(r => setTimeout(r, 2000));
    const reply = lookupReply(text);
    const container = typingNode.querySelector('.text');
    if(container) container.textContent = reply;
    history.push({role:'bot', text:reply}); persistHistory();
    chatArea.scrollTop = chatArea.scrollHeight;
    sendLock = false;
  }
  function persistHistory(){ try{ localStorage.setItem('gh_history', JSON.stringify(history)); }catch(e){} }

  // initial render
  renderHistory();

  // Submission
  if(inputForm){
    inputForm.addEventListener('submit', function(e){
      e.preventDefault();
      handleSend(userInput && userInput.value);
    });
  }

  // panel helpers
  function positionPanelAboveBubble(){
    if(!panel || !bubble) return;
    try{
      // Reset both left/right to allow accurate positioning
      panel.style.left = 'auto'; panel.style.right = 'auto';
      const panelRect = panel.getBoundingClientRect();
      const bubbleRect = bubble.getBoundingClientRect();

      // Prefer placing panel above the bubble and either to its left or right depending on space
      const spaceRight = window.innerWidth - bubbleRect.right;
      const spaceLeft = bubbleRect.left;
      const margin = 12;

      // compute target left coordinate for panel
      if(spaceRight >= panelRect.width + margin){
        // place panel to right of bubble
        panel.style.left = (bubbleRect.right + margin) + 'px';
        // ensure not exceeding viewport
        const leftVal = parseFloat(panel.style.left);
        if(leftVal + panelRect.width > window.innerWidth - margin) panel.style.left = (window.innerWidth - margin - panelRect.width) + 'px';
      } else if(spaceLeft >= panelRect.width + margin){
        // place panel to left of bubble
        panel.style.left = Math.max(margin, bubbleRect.left - margin - panelRect.width) + 'px';
      } else {
        // default: align horizontally centered near bubble but keep inside viewport
        const centered = Math.min(Math.max(margin, bubbleRect.left + bubbleRect.width/2 - panelRect.width/2), window.innerWidth - panelRect.width - margin);
        panel.style.left = centered + 'px';
      }

      // vertical: try to place above bubble if there's room, otherwise below
      const aboveSpace = bubbleRect.top;
      const belowSpace = window.innerHeight - bubbleRect.bottom;
      if(aboveSpace > panelRect.height + margin){
        panel.style.top = Math.max(margin, bubbleRect.top - panelRect.height - margin) + 'px';
      } else if (belowSpace > panelRect.height + margin){
        panel.style.top = Math.min(window.innerHeight - panelRect.height - margin, bubbleRect.bottom + margin) + 'px';
      } else {
        // fit into viewport centered vertically
        const topCentered = Math.min(Math.max(margin, window.innerHeight/2 - panelRect.height/2), window.innerHeight - panelRect.height - margin);
        panel.style.top = topCentered + 'px';
      }

    }catch(e){
      panel.style.right = '18px';
      panel.style.bottom = '110px';
    }
  }
  async function openPanel(){
    if(!panel) return;
    // attempt to (re)load qa.json before first interaction (best-effort)
    await fetchQA().catch(()=>{});
    panel.classList.add('show'); panel.setAttribute('aria-hidden','false'); positionPanelAboveBubble();
    setTimeout(()=>{ try{ if(userInput){ userInput.focus(); chatArea.scrollTop = chatArea.scrollHeight; } }catch(e){} }, 60);
  }
  function minimizePanel(){ if(!panel) return; panel.classList.remove('show'); panel.setAttribute('aria-hidden','true'); }

  // bubble interactions: click toggles, but drag has priority
  bubble.addEventListener('keydown', function(e){ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); if(panel && panel.classList && panel.classList.contains('show')) minimizePanel(); else openPanel(); } });

  // click outside closes panel unless modal open
  document.addEventListener('click', function(ev){
    if(!panel || !bubble) return;
    if(!panel.classList.contains('show')) return;
    if(modalBackdrop && modalBackdrop.classList.contains('show')) return;
    if(panel.contains(ev.target) || bubble.contains(ev.target)) return;
    minimizePanel();
  });

  // modal behavior
  if(gearBtn){
    gearBtn.addEventListener('click', function(ev){
      ev && ev.stopPropagation();
      modalBackdrop.classList.add('show'); modalBackdrop.classList.remove('hidden');
      try{ kidsModeCheckbox.checked = JSON.parse(localStorage.getItem('gh_kids')||'false'); privateModeCheckbox.checked = JSON.parse(localStorage.getItem('gh_private')||'false'); }catch(e){}
    });
  }
  if(closeModal){
    closeModal.addEventListener('click', function(){
      modalBackdrop.classList.remove('show'); modalBackdrop.classList.add('hidden');
      try{ localStorage.setItem('gh_kids', JSON.stringify(kidsModeCheckbox.checked)); localStorage.setItem('gh_private', JSON.stringify(privateModeCheckbox.checked)); }catch(e){}
    });
  }
  modalBackdrop.addEventListener('click', function(ev){ if(ev.target === modalBackdrop){ modalBackdrop.classList.remove('show'); modalBackdrop.classList.add('hidden'); }});

  // clear history button
  if(clearHistoryBtn){
    clearHistoryBtn.addEventListener('click', function(ev){
      ev && ev.preventDefault();
      history = [{role:'bot', text: (qaData['clear history success'] || 'History cleared.')}];
      persistHistory(); renderHistory();
    });
  }

  // minimize button
  if(minBtn) minBtn.addEventListener('click', function(ev){ ev && ev.stopPropagation(); minimizePanel(); });

  // DRAG: use left/top coordinates and clamp to viewport. snap to edges on release.
  (function enableDrag(){
    if(!bubble) return;
    let dragging = false;
    let startX = 0, startY = 0;
    let startLeft = null, startTop = null;
    let moved = false;
    const threshold = 6;
    const margin = 12;

    // initialize saved position
    try{
      const saved = JSON.parse(localStorage.getItem('gh_bubble_pos') || 'null');
      if(saved && typeof saved.left === 'number' && typeof saved.top === 'number'){
        bubble.style.left = saved.left + 'px';
        bubble.style.top = saved.top + 'px';
        bubble.style.right = 'auto';
        bubble.style.bottom = 'auto';
      }
    }catch(e){}

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function pointerDown(e){
      e.preventDefault();
      dragging = true;
      moved = false;
      const p = e.touches ? e.touches[0] : e;
      startX = p.clientX; startY = p.clientY;
      const rect = bubble.getBoundingClientRect();
      // compute startLeft/startTop (resolve either left/top or compute from right/bottom)
      const computed = window.getComputedStyle(bubble);
      if(computed.left && computed.left !== 'auto'){
        startLeft = parseFloat(computed.left);
      } else {
        // derive from right/bottom if left not set
        startLeft = rect.left;
      }
      if(computed.top && computed.top !== 'auto'){
        startTop = parseFloat(computed.top);
      } else {
        startTop = rect.top;
      }
      // ensure absolute positioning values are set
      bubble.style.left = startLeft + 'px';
      bubble.style.top = startTop + 'px';
      bubble.style.right = 'auto';
      bubble.style.bottom = 'auto';
    }

    function pointerMove(e){
      if(!dragging) return;
      const p = e.touches ? e.touches[0] : e;
      const dx = p.clientX - startX;
      const dy = p.clientY - startY;
      if(!moved && (Math.abs(dx) > threshold || Math.abs(dy) > threshold)) moved = true;
      const newLeft = startLeft + dx;
      const newTop = startTop + dy;
      const rect = bubble.getBoundingClientRect();
      const maxLeft = window.innerWidth - rect.width - margin;
      const maxTop = window.innerHeight - rect.height - margin;
      const clampedLeft = clamp(newLeft, margin, Math.max(margin, maxLeft));
      const clampedTop = clamp(newTop, margin, Math.max(margin, maxTop));
      bubble.style.left = clampedLeft + 'px';
      bubble.style.top = clampedTop + 'px';
      e.preventDefault && e.preventDefault();
    }

    function pointerUp(e){
      if(!dragging) return;
      dragging = false;
      // if not moved => click toggle
      if(!moved){
        // treat as click / toggle
        if(panel && panel.classList && panel.classList.contains('show')) minimizePanel(); else openPanel();
        return;
      }
      // else snap to nearest horizontal edge while preserving vertical within bounds
      const rect = bubble.getBoundingClientRect();
      const centerX = rect.left + rect.width/2;
      const snappedLeft = centerX < window.innerWidth/2 ? margin : window.innerWidth - rect.width - margin;
      const clampedTop = clamp(rect.top, margin, Math.max(margin, window.innerHeight - rect.height - margin));
      // animate to snapped position
      bubble.style.transition = 'left .16s ease, top .12s ease';
      bubble.style.left = snappedLeft + 'px';
      bubble.style.top = clampedTop + 'px';
      setTimeout(()=> bubble.style.transition = '', 220);
      // persist
      try{ localStorage.setItem('gh_bubble_pos', JSON.stringify({ left: snappedLeft, top: clampedTop })); }catch(e){}
      // reposition panel to follow
      setTimeout(positionPanelAboveBubble, 60);
    }

    // pointer events
    bubble.addEventListener('pointerdown', pointerDown, {passive:false});
    window.addEventListener('pointermove', pointerMove, {passive:false});
    window.addEventListener('pointerup', pointerUp, {passive:false});
    // support touch as well (some browsers)
    bubble.addEventListener('touchstart', pointerDown, {passive:false});
    window.addEventListener('touchmove', pointerMove, {passive:false});
    window.addEventListener('touchend', pointerUp, {passive:false});
    // mouse fallback
    bubble.addEventListener('mousedown', pointerDown);
    window.addEventListener('mousemove', pointerMove);
    window.addEventListener('mouseup', pointerUp);
  })();

  // keyboard & mobile safety (keep input visible)
  if(userInput){
    userInput.addEventListener('focus', ()=> setTimeout(()=> {
      if(panel && !panel.classList.contains('show')) openPanel();
      try{
        const vh = window.innerHeight || document.documentElement.clientHeight;
        panel.style.maxHeight = Math.max(300, vh - 120) + 'px';
        chatArea.scrollTop = chatArea.scrollHeight;
      }catch(e){}
    }, 250));
    userInput.addEventListener('blur', ()=> setTimeout(()=> { try{ panel.style.maxHeight = Math.min(window.innerHeight - 120, 86 * window.innerHeight / 100) + 'px'; }catch(e){} },150));
    let lastInner = window.innerHeight;
    window.addEventListener('resize', function(){
      try{
        const now = window.innerHeight;
        if(now < lastInner - 80){ panel.style.maxHeight = Math.max(260, now - 120) + 'px'; setTimeout(()=> chatArea.scrollTop = chatArea.scrollHeight, 60); }
        else panel.style.maxHeight = Math.min(now - 120, 86 * now / 100) + 'px';
        lastInner = now;
      }catch(e){}
    });
  }

  // reposition on orientation/resize
  window.addEventListener('orientationchange', ()=> setTimeout(positionPanelAboveBubble, 320));
  window.addEventListener('resize', ()=> setTimeout(positionPanelAboveBubble, 120));

})(); // end IIFE
</script>
</body>
</html>
